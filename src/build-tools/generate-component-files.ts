import { dir, file } from '../lib/file';
import { getNames } from '../lib/get-names';
import * as path from 'path';
import { readWorksConfigFile } from '../lib/read-works-config';
import { Table, TableColumn } from '../types/table';
import { WorksConfigFile } from '../types/config-file';
import { tableTsTypeMap } from './maps/table-ts-type';
import { tableDbTypeMap } from './maps/table-db-type';
import { queryParamTypes } from './maps/query-param-types';
import { csvTypeMap } from './maps/csv-type';

function getColumnTsType(col: TableColumn): string {
  let tsType = tableTsTypeMap[col.type];
  if (tsType === '') {
    if (col.type === 'json' || col.type === 'jsonb') {
      tsType  = `any; // json column typings not yet implemented`;
    } else if (col.type === 'enum') {
      if (!Array.isArray(col.enumValues)) throw Error('column.enumValues needs to be string[] when column.type is enum');
      tsType = col.enumValues.map(val => `'${val}'`).join(' | ');
    }
  }
  return `  ${col.name}: ${tsType};`;
}



function getColumnQueryType(col: TableColumn): string {
  return `${col.name}: ${
    col.type === 'enum' 
      ? `[${(col.enumValues as string[]).map(val => `'${val}'`).join(', ')}]`
      : `'${queryParamTypes[col.type]}'`
  },`;
}

function getCsvColumn(col: TableColumn): string {
  const names = getNames(col.name);
  return `{prop: '${col.name}', type: '${csvTypeMap[col.type]}', label: '${names.single.title}'},`
}

export function getVariables(table: Table, config: WorksConfigFile, component: string) {
  const names = getNames(component);
  const primaryColumnNames = table.primary 
    ? Array.isArray(table.primary) 
      ? table.primary 
      : [table.primary]
    : table.columns.filter(col => col.primary)
    .map(col => col.name);
  const primaryColumns = primaryColumnNames.map(name => table.columns.find(col => col.name === name)).filter(x => x) as TableColumn[];
  return {
    model_name: names.single.pascal,
    query_name: names.single.pascal,
    ts_name: names.single.camel,
    csv_filename: names.plural.kebab,
    sql_table: names.plural.camel,
    query_name_plural: names.plural.pascal,
    query_primary: primaryColumnNames.map(col => getNames(col).single.pascal).join(''),
    ts_column_names: table.columns.map(col => `'${col.name}',`).join('\n  '),
    sql_columns: table.columns.map(col => `"${col.name}"`).join(',\n        '),
    sql_insert_columns: table.columns.map(col => col.type === 'json' || col.type === 'jsonb' ? '${JSON.stringify(payload.' + col.name + ')}' : '${payload.' + col.name + '}').join(',\n        '),
    ts_insert: table.columns.map(col => `payload.${col.name}`).join(',\n          '),
    sql_column_types: table.columns.map(col => `'${tableDbTypeMap[col.type]}'`).join(',\n          '),
    ts_primary: primaryColumnNames[0] === '' ? '// no primary columns in the table' : primaryColumns.map(getColumnTsType).join('\n  '),
    sql_primary_where: primaryColumnNames[0] === '' ? 'TRUE' : primaryColumnNames
      .map(col => `"${col}" = ${'${query.' + col + '}'}`).join(' AND\n        '),
    sql_all_where: table.columns.map(col => `"${col.name}" = ${'${query.' + col.name + '}'}`).join(' AND\n        '),
    sql_primary_comma: primaryColumnNames[0] === '' ? '' : primaryColumnNames.map(col => `"${col}"`).join(',\n'),
    sql_columns_set: table.columns.filter(col => !primaryColumnNames.includes(col.name))
      .map(col => `"${col.name}" = ${'${payload.' + col.name + '}'}`).join(',\n        '),
    ts_model_props: table.columns.map(getColumnTsType).join('\n  '),
    endpoint: names.plural.lower,
    endpoint_primary_param: primaryColumnNames[0] === '' ? '' : primaryColumnNames.map(name => ':' + name).join('/'),
    ts_endpoint_primary_query: primaryColumnNames[0] === '' ? 'undefined' : `{${primaryColumns.map(getColumnQueryType).join(' ')}}`,
    ts_endpoint_all_query: table.columns.map(getColumnQueryType).join('\n  '),
    csv_columns: table.columns.filter(col => col.type !== 'json' && col.type !== 'jsonb').map(getCsvColumn).join('\n  '),
  }
}

function applyVariables(variables: ReturnType<typeof getVariables>, str: string): string {
  return str.replace(/\$\[([^\]]+)\]/g, (_: string, prop: string ) => {
    const value = variables[prop as keyof ReturnType<typeof getVariables>];
    if (typeof value === 'undefined') throw Error(`Variable ${prop} not generated by getVariables`);
    return value;
  })
}

const dirs = [
  'queries',
  'types',
  '.',
]

async function isFileLocked(filePath: string): Promise<boolean> {
  if (!(await file.exists(filePath))) return false;
  const fileText = await file.read.text(filePath);
  const match = fileText.match(/\@works-lock-file\:\s*(\S+)/);
  if (!match || !match[1]) return false;
  return match[1].toLowerCase() === 'true';

}

export async function generateComponentFiles(componentPath: string, table: Table) {
  const worksConfig = readWorksConfigFile();
  const variables = getVariables(table, worksConfig, path.basename(componentPath));
  const scaffoldingDir = path.join(__dirname, '../../../assets/component-template');
  await Promise.all(dirs.map(async partialDir => {
    const sourceDir = path.join(scaffoldingDir, partialDir)
    const targetDir = path.join(componentPath, partialDir);
    await dir.createIfNotExists(targetDir);
    const files = await dir.read(sourceDir);
    await Promise.all(files.map(async filename => {
      const sourceFile = path.join(scaffoldingDir, partialDir, filename);
      const targetFile = path.join(componentPath, partialDir, applyVariables(variables, filename).replace(/\.txt/, '.ts'));
      if ((await file.stats(sourceFile)).isDirectory()) return;
      if (await isFileLocked(targetFile)) return;
      const text = await file.read.text(path.join(scaffoldingDir, partialDir, filename));
      await file.write.text(targetFile, applyVariables(variables, text));
    }));
  }));
}
